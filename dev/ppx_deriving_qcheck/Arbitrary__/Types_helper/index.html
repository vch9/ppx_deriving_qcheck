<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Types_helper (ppx_deriving_qcheck.Arbitrary__.Types_helper)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">ppx_deriving_qcheck</a> &#x00BB; <a href="../index.html">Arbitrary__</a> &#x00BB; Types_helper</nav><h1>Module <code>Arbitrary__.Types_helper</code></h1></header><aside><p>Module helping with OCaml types as QCheck.arbitrary</p></aside><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : string <span>&#45;&gt;</span> string</code></dt><dd><p>Convention generator name for any type name</p></dd></dl><dl><dt class="spec module" id="module-Primitive"><a href="#module-Primitive" class="anchor"></a><code><span class="keyword">module</span> <a href="Primitive/index.html">Primitive</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module representing OCaml primitives types supported</p></dd></dl><dl><dt class="spec value" id="val-constr_type"><a href="#val-constr_type" class="anchor"></a><code><span class="keyword">val</span> constr_type : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>f:Ppxlib.expression</span> <span>&#45;&gt;</span> <span>args:<span>Ppxlib.expression list</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>constr_type loc f args ()</code> transforms an applicated parametrizable type into a QCheck arbitrary.</p><p>In that example, string is a parametrizable type applied on list</p><pre><code class="ml">type t = string list [@@gen]

let gen_t = QCheck.list QCheck.string</code></pre></dd></dl><dl><dt class="spec value" id="val-from_longident"><a href="#val-from_longident" class="anchor"></a><code><span class="keyword">val</span> from_longident : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>recursives_types:<span>string list</span></span> <span>&#45;&gt;</span> <span>mutual_types:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.longident <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>from_longident loc recursives_types mutual_types lg</code> transforms <code>lg</code> into a QCheck.arbitrary</p><p>Multiples cases:</p><ul><li>The type is a identifier we use <code>from_string</code></li><li>The type comes from an outside module, we require a generator inside that outside module</li><li>The type is an application, we raise an exception</li></ul></dd></dl><dl><dt class="spec value" id="val-nest_gens"><a href="#val-nest_gens" class="anchor"></a><code><span class="keyword">val</span> nest_gens : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>Ppxlib.expression list</span> <span>&#45;&gt;</span> Ppxlib.expression * <span>string list</span> * Ppxlib.pattern</code></dt><dd><p>Transform list of generators into a triple:</p><ul><li>expressions nested with QCheck.pair expression</li><li>generators names used in the expression</li><li>pattern according to the nested expression</li></ul></dd></dl><dl><dt class="spec value" id="val-record'"><a href="#val-record'" class="anchor"></a><code><span class="keyword">val</span> record' : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>gens:<span>Ppxlib.expression list</span></span> <span>&#45;&gt;</span> <span>Ppxlib.label_declaration list</span> <span>&#45;&gt;</span> Ppxlib.pattern * Ppxlib.expression * Ppxlib.expression</code></dt><dd><p><code>record' loc gens label_decls</code> is an auxiliar function of <a href="index.html#val-record"><code>record</code></a>. It extracts the pattern and according expression for <code>gens</code>, also extracts the record's construction expression.</p><p>type t = <code>left : int ; right = string </code></p><p>record' <code>QCheck.int; QCheck.string</code> <code> left -&gt; int ; right -&gt; string </code> =&gt;</p><ul><li>pattern : (arb_0, arb_1)</li><li>generators : pair QCheck.int QCheck.string</li><li>expression : <code> left = arb_0 ; right = arb_1 </code></li></ul></dd></dl><dl><dt class="spec value" id="val-record"><a href="#val-record" class="anchor"></a><code><span class="keyword">val</span> record : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>gens:<span>Ppxlib.expression list</span></span> <span>&#45;&gt;</span> <span>Ppxlib.label_declaration list</span> <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>record loc gens label_decls</code> convert <code>gens</code> and <code>label_decls</code> in a application of a record type using <span class="xref-unresolved" title="unresolved reference to &quot;QCheck.map&quot;"><code>QCheck</code>.map</span>.</p><p>Example:</p><pre><code class="ml">type t = { left : int ; right : string } [@@gen]

let gen_t =
  QCheck.map (fun (x,y) -&gt; { left = x ; right = y })
  (QCheck.pair QCheck.int QCheck.string)</code></pre></dd></dl><dl><dt class="spec value" id="val-tuple'"><a href="#val-tuple'" class="anchor"></a><code><span class="keyword">val</span> tuple' : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>Ppxlib.expression list</span> <span>&#45;&gt;</span> Ppxlib.pattern * Ppxlib.expression * Ppxlib.expression</code></dt><dd><p><code>tuple' loc arbs </code> is a <a href="index.html#val-tuple"><code>tuple</code></a> auxiliar function, it extracts the pattern for a constructor application, the list of generators needed and the record expression</p><p>type t = int * string</p><p>tuple' <code>int; string</code> =&gt;</p><ul><li>pattern : (arb_0, arb_1)</li><li>generators : pair QCheck.int QCheck.string</li><li>expression : (arb_0 * arb_1)</li></ul></dd></dl><dl><dt class="spec value" id="val-tuple"><a href="#val-tuple" class="anchor"></a><code><span class="keyword">val</span> tuple : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>Ppxlib.expression list</span> <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>tuple loc arbs</code> converts <code>arbs</code> in a application of a tuple</p><p>Example:</p><pre><code class="ml">type t = int * int * int

let gen_t =
  QCheck.map (fun (x,y,z) -&gt; (x,y,z))
  (QCheck.triple int int int)</code></pre></dd></dl><dl><dt class="spec value" id="val-constructors"><a href="#val-constructors" class="anchor"></a><code><span class="keyword">val</span> constructors : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span><span>(<span>Ppxlib.expression option</span> * Ppxlib.expression)</span> list</span> <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>constructors loc xs</code> convert a list of (weight option * constructor) into a single expression choosing the constructor using it's weight (1 if it's not provided).</p><p>Example:</p><pre><code class="ml">type t =
| A [@weight 5]
| B [@weight 6]
| C
[@@gen]

let gen_t =
  let open QCheck in
  frequency [ (5, always A) ;
              (6, always B) ;
              (1, always C) ]</code></pre></dd></dl><dl><dt class="spec value" id="val-constructor"><a href="#val-constructor" class="anchor"></a><code><span class="keyword">val</span> constructor : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>kname:string</span> <span>&#45;&gt;</span> <span>?&#8288;kargs:<span>(Ppxlib.pattern * Ppxlib.expression * Ppxlib.expression)</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p>TODO: ocamldoc that comment</p><p>Convert a constructor name into an expression constructor QCheck.arbitrary</p><p>Example:</p><pre><code class="ml">type t =
| A

(* A =&gt; QCheck.make @@ QCheck.Gen.return A *)</code></pre><p>An additional case is supported when constructor requires arguments</p><p>Example:</p><pre><code class="ml">type t =
| A of int * string
| B of { left : int ; right : string }

(* A =&gt; QCheck.map (fun (x,y) -&gt; A (x,y)) QCheck.(pair int string)
   B =&gt; QCheck.map (fun (x,y) -&gt; B { left = x ; right ; y }) QCheck.(pair int string) *)</code></pre></dd></dl><dl><dt class="spec value" id="val-tree'"><a href="#val-tree'" class="anchor"></a><code><span class="keyword">val</span> tree' : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>leaves:Ppxlib.expression</span> <span>&#45;&gt;</span> <span>nodes:Ppxlib.expression</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>tree' loc leaves nodes ()</code> is almost the same function as <a href="index.html#val-tree'"><code>tree'</code></a> the only difference is that QCheck.frequency is already applied to leaves and nodes</p></dd></dl><dl><dt class="spec value" id="val-tree"><a href="#val-tree" class="anchor"></a><code><span class="keyword">val</span> tree : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>leaves:<span><span>(<span>Ppxlib.expression option</span> * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>nodes:<span><span>(<span>Ppxlib.expression option</span> * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>tree loc leaves nodes ()</code> transforms a tree type like into a recursive arbitrary expression</p><p>The recursive arbitrary uses a fuel, we could imagine that in future work the fuel would be provided by the user.</p><p>Example:</p><pre><code class="ml">type t = Tree | Node of int * leaf * leaf
[@@deriving arb]

let rec arb_tree fuel =
  let open QCheck in
  match fuel with
  | 0 -&gt; frequency [(1, always Leaf)]
  | n -&gt;
    frequency
      [
        (1, always Leaf) ;
        (1, map
          (fun (arb_0, (arb_1, arb_2)) -&gt; Node (arb_0, arb_1, arb_2))
          (pair int
             (pair (arb_tree (n - 1)) (arb_tree (n - 1)))))
      ]

let arb_tree = arb_tree 5</code></pre></dd></dl><dl><dt class="spec value" id="val-variants"><a href="#val-variants" class="anchor"></a><code><span class="keyword">val</span> variants : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>ty:string</span> <span>&#45;&gt;</span> <span><span>[&lt; <span>`RTag of string * <span>Ppxlib.expression option</span> * <span>Ppxlib.expression list</span></span> <span><span>| `RInh</span> of <span>Ppxlib.expression option</span> * Ppxlib.expression</span> ]</span> list</span> <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>variants loc ty xs</code> create a QCheck.arbitrary using <code>xs</code> to produce Ptyp_variant _ list. We also require <code>ty</code> to constraint the expression to a </p><pre><code class="ml">t QCheck.arbitrary </code></pre><p>where </p><pre><code class="ml">t </code></pre><p>is the current type we are deriving.</p><p>`RTag represents the direct declaration of a variant </p><pre><code class="ml">type t = [`A]</code></pre><p>`RInh represents an inheritage of another variant </p><pre><code class="ml">type t' = [`B | t]</code></pre><p>Each variant can have a specific weight, see <a href="index.html#val-constructors"><code>constructors</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-gen"><a href="#val-gen" class="anchor"></a><code><span class="keyword">val</span> gen : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>is_rec:bool</span> <span>&#45;&gt;</span> <span>args:<span>Ppxlib.pattern list</span></span> <span>&#45;&gt;</span> <span>ty:string</span> <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.structure_item</code></dt><dd><p><code>gen loc is_rec args ty body</code> create a QCheck.arbitrary for <code>ty</code></p><p>When <code>is_rec</code> is false we produce the following structure_item:</p><pre><code class="ml">let arb_ty args = body </code></pre><p>The specific case where <code>is_rec</code> is true, the generator is self_recursive and we produce the following expression</p><pre><code class="ml">let arb_ty () = arb_ty' 5
and arb_ty' fuel =
  match fuel with
  | 0 -&gt; (* leaves *)
  | n -&gt; (* recursives calls *)
and arb_ty = arb_ty ()</code></pre><p>(TODO: I did not test self recursive type with parameters inside args)</p><p>(TODO: name gen is misleading, for now we produce an arbitrary but this will be later on transformed into a Gen.t)</p></dd></dl><dl><dt class="spec value" id="val-gens"><a href="#val-gens" class="anchor"></a><code><span class="keyword">val</span> gens : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>tys:<span>string list</span></span> <span>&#45;&gt;</span> <span>gens:<span>Ppxlib.structure_item list</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> Ppxlib.structure_item</code></dt><dt class="spec value" id="val-observable"><a href="#val-observable" class="anchor"></a><code><span class="keyword">val</span> observable : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> Ppxlib.core_type <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>observable loc x</code> create an QCheck.Observable.t if <code>x</code> is an observable</p></dd></dl><dl><dt class="spec value" id="val-fun_nary"><a href="#val-fun_nary" class="anchor"></a><code><span class="keyword">val</span> fun_nary : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>Ppxlib.expression list</span> <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>fun_nary loc obs x</code> create an ('a Tuple.t -&gt; 'b) fun_ arbitrary</p></dd></dl></div></body></html>